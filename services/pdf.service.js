const PDFDocument = require('pdfkit');
const fs = require('fs');

// --- Main Dispatcher Function ---
function buildReportPDF(dataCallback, endCallback, reportData) {
  switch (reportData.reportType) {
    case 'Jobcard':
      return buildJobcardReportPDF(dataCallback, endCallback, reportData);
    case 'Inventory':
      return buildInventoryReportPDF(dataCallback, endCallback, reportData);
    case 'Hardware':
      return buildHardwareReportPDF(dataCallback, endCallback, reportData);
    case 'Consumption':
      return buildConsumptionReportPDF(dataCallback, endCallback, reportData);
    default:
      throw new Error(`PDF generation for report type '${reportData.reportType}' is not supported.`);
  }
}

// --- Builder for Jobcard Reports (Correct) ---
function buildJobcardReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);

  generateHeader(doc);
  addMainTitle(doc, 'Medication Order Report (Jobcard)');
  
  const { Jobcard: jobcard, User: generatedByUser } = reportData;
  if (jobcard) {
    addSectionHeader(doc, 'Jobcard Summary');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Jobcard ID', jobcard.jobcardId, col1), () => addKeyValue(doc, 'Status', jobcard.status, col1), () => addKeyValue(doc, 'Urgency', jobcard.emergencyLevel, col1), () => addKeyValue(doc, 'Quantity', jobcard.quantity, col1), () => addKeyValue(doc, 'Purpose/Notes', jobcard.purpose, col1) ], [ () => addKeyValue(doc, 'Report ID', reportData.reportId, col2), () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2) ] ]);
    });
    addSectionHeader(doc, 'Timeline & Personnel');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Requested By', jobcard.requester?.username, col1), () => addKeyValue(doc, 'Request Date', new Date(jobcard.requestDate).toLocaleString(), col1), ], [ () => addKeyValue(doc, 'Approved By', jobcard.approver?.username, col2), () => addKeyValue(doc, 'Approval Date', jobcard.approveDate ? new Date(jobcard.approveDate).toLocaleString() : 'N/A', col2), ] ]);
    });
    if (jobcard.Dilution) {
        addSectionHeader(doc, 'Medication Details');
        drawBoxAround(doc, () => {
            let startY = doc.y; const col1X = 60; const col2X = 340;
            addKeyValue(doc, 'Final Product (Dilution)', jobcard.Dilution.name, { x: col1X, keyWidth: 150 });
            if (jobcard.Dilution.Formula) { addKeyValue(doc, 'Recipe Used (Formula)', jobcard.Dilution.Formula.name, { x: col1X, keyWidth: 150 }); }
            const leftHeight = doc.y;
            doc.y = startY;
            if (jobcard.Dilution.Formula) {
                doc.font('Helvetica-Bold').fontSize(10).text('Ingredients Required:', col2X, doc.y, { underline: true });
                doc.moveDown(0.5);
                const ingredients = jobcard.Dilution.Formula.FormulaDetails;
                if (ingredients?.length > 0) {
                    ingredients.forEach(detail => { doc.font('Helvetica').fontSize(9).text(`• ${detail.Inventory.name} | Qty: ${detail.requiredQuantity}`, col2X + 10, doc.y, { width: 180 }); });
                } else { doc.font('Helvetica').fontSize(9).text('• No ingredients listed.', col2X + 10); }
            }
            const rightHeight = doc.y;
            doc.y = Math.max(leftHeight, rightHeight);
        });
    }
    addSectionHeader(doc, 'Associated Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 110 };
        drawColumns(doc, [ [ () => jobcard.PrescriptionDetail && addKeyValue(doc, 'Patient Age', jobcard.PrescriptionDetail.age, col1), () => jobcard.PrescriptionDetail && addKeyValue(doc, 'Patient Weight', `${jobcard.PrescriptionDetail.weight} kg`, col1), () => jobcard.PrescriptionDetail && addKeyValue(doc, 'Patient Allergies', jobcard.PrescriptionDetail.allergies, col1) ], [ () => jobcard.Hardware && addKeyValue(doc, 'Equipment Used', jobcard.Hardware.name, col2) ] ]);
    });
  }
  generateFooter(doc);
  doc.end();
}

// --- FINALIZED Builder for Inventory Reports ---
function buildInventoryReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);
  
  generateHeader(doc);
  addMainTitle(doc, 'Inventory Item Report');
  
  const { Inventory: item, User: generatedByUser } = reportData;
  if (item) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 };
        const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ],
            [ 
                () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2),
                () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2)
            ]
        ]);
    });

    addSectionHeader(doc, 'Item Details');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 120 };
        const col2 = { x: 340, keyWidth: 100 };
        drawColumns(doc, [
            [
                () => addKeyValue(doc, 'Item ID:', item.inventoryId, col1),
                () => addKeyValue(doc, 'Item Name:', item.name, col1),
                () => addKeyValue(doc, 'Current Quantity:', `${item.quantity} ${item.unit || ''}`, col1),
                () => addKeyValue(doc, 'Status:', item.status, col1)
            ],
            [
                () => addKeyValue(doc, 'Supplier:', item.supplier, col2),
                () => addKeyValue(doc, 'Batch Number:', item.batchNumber, col2),
                () => addKeyValue(doc, 'Expiry Date:', item.expired ? new Date(item.expired).toLocaleDateString() : 'N/A', col2)
            ]
        ]);
    });
  }
  
  generateFooter(doc);
  doc.end();
}

// --- FINALIZED Builder for Hardware Reports ---
function buildHardwareReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);

  generateHeader(doc);
  addMainTitle(doc, 'Medical Equipment Report');

  const { Hardware: hardware, User: generatedByUser } = reportData;
  if (hardware) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 };
        const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ],
            [
                () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2),
                () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2)
            ]
        ]);
    });

    addSectionHeader(doc, 'Equipment Details');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 110 };
        const col2 = { x: 340, keyWidth: 120 };
        drawColumns(doc, [
            [
                () => addKeyValue(doc, 'Equipment ID:', hardware.hardwareId, col1),
                () => addKeyValue(doc, 'Equipment Name:', hardware.name, col1),
                () => addKeyValue(doc, 'Status:', hardware.status ? 'Online / Active' : 'Offline / Inactive', col1)
            ],
            [
                () => addKeyValue(doc, 'Description:', hardware.description, col2),
                () => addKeyValue(doc, 'Last Maintenance:', hardware.lastMaintenanceDate ? new Date(hardware.lastMaintenanceDate).toLocaleString() : 'N/A', col2)
            ]
        ]);
    });
  }
  
  generateFooter(doc);
  doc.end();
}

// --- FINALIZED Builder for Consumption Reports ---
function buildConsumptionReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);
  
  generateHeader(doc);
  addMainTitle(doc, 'Inventory Consumption Report');
  
  const { Consumption: consumption, User: generatedByUser } = reportData;
  if (consumption) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 };
        const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ],
            [
                () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2),
                () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2)
            ]
        ]);
    });

    addSectionHeader(doc, 'Consumption Event');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 };
        const col2 = { x: 340, keyWidth: 110 };
        drawColumns(doc, [
            [
                () => addKeyValue(doc, 'Consumption ID:', consumption.consumptionId, col1),
                () => addKeyValue(doc, 'Date:', new Date(consumption.consumptionDate).toLocaleString(), col1)
            ],
            [
                () => consumption.Inventory && addKeyValue(doc, 'Item Consumed:', `${consumption.Inventory.name} (ID: ${consumption.Inventory.inventoryId})`, col2),
                () => consumption.Inventory && addKeyValue(doc, 'Quantity Used:', `${consumption.quantityUsed} ${consumption.Inventory.unit || ''}`, col2)
            ]
        ]);
    });

    addSectionHeader(doc, 'Source of Consumption');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 140 };
        const col2 = { x: 340, keyWidth: 120 };
        drawColumns(doc, [
            [ () => consumption.Jobcard && addKeyValue(doc, 'Triggering Jobcard ID:', consumption.Jobcard.jobcardId, col1) ],
            [ () => consumption.Formula && addKeyValue(doc, 'As part of Formula:', `${consumption.Formula.name} (ID: ${consumption.Formula.formulaId})`, col2) ]
        ]);
    });
  }
  
  generateFooter(doc);
  doc.end();
}


// --- Finalized Helper Functions (Correct) ---

function generateHeader(doc) {
  doc.on('pageAdded', () => {
    const pageWidth = doc.page.width;
    doc.font('Helvetica-Bold').fontSize(20).text('TheDilution System', { align: 'center' });
    doc.moveDown(0.3);
    doc.font('Helvetica').fontSize(10).text('Pusat Pengajian Sains Komputer, USM', { align: 'center' });
    doc.strokeColor("#aaaaaa").lineWidth(1).moveTo(50, 100).lineTo(pageWidth - 50, 100).stroke();
  });
  doc.emit('pageAdded');
}

function generateFooter(doc) {
  const pageCount = doc.bufferedPageRange().count;
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i);
    doc.strokeColor("#aaaaaa").lineWidth(1).moveTo(50, 720).lineTo(doc.page.width - 50, 720).stroke();
    doc.fontSize(10).font('Helvetica').text('TheDilution System © 2025', 50, 730, { align: 'left' });
    doc.fontSize(10).text(`Page ${i + 1} of ${pageCount}`, 0, 730, { align: 'right' });
  }
}

function addMainTitle(doc, title) {
    doc.y = 120;
    doc.fontSize(16).font('Helvetica-Bold').text(title, { align: 'center' });
    doc.moveDown(2);
}

function addSectionHeader(doc, title) {
  if (doc.y > 650) doc.addPage();
  doc.fontSize(14).font('Helvetica-Bold').text(title, { underline: true });
  doc.moveDown(1);
}

function addKeyValue(doc, key, value, options = {}) {
  const { x, keyWidth = 120 } = options;
  let startY = doc.y;
  const startX = x || doc.x;
  if (startY > 680) { doc.addPage(); startY = doc.y; }
  const valueX = startX + keyWidth;
  const valueWidth = (doc.page.width - doc.page.margins.right) - valueX;
  const keyHeight = doc.heightOfString(key, { width: keyWidth });
  const valueHeight = doc.heightOfString(`: ${value || 'N/A'}`, { width: valueWidth });
  doc.font('Helvetica-Bold').fontSize(10).text(key, startX, startY, { width: keyWidth, align: 'left' });
  doc.font('Helvetica').text(`: ${value || 'N/A'}`, valueX, startY, { width: valueWidth, align: 'left' });
  doc.y = startY + Math.max(keyHeight, valueHeight) + 5;
}

function drawBoxAround(doc, contentCallback) {
    const startY = doc.y;
    const startX = 50;
    if (startY > 650) doc.addPage();
    doc.y += 10;
    contentCallback();
    const finalY = doc.y;
    doc.rect(startX, startY - 5, doc.page.width - 100, finalY - startY).strokeColor("#cccccc").lineWidth(0.5).stroke();
    doc.x = startX;
    doc.y = finalY + 15;
}

function drawColumns(doc, columns) {
    let startY = doc.y;
    let maxHeight = 0;
    columns.forEach(columnItems => {
        doc.y = startY;
        columnItems.forEach(itemFunc => { if (itemFunc) itemFunc(); });
        maxHeight = Math.max(maxHeight, doc.y);
    });
    doc.y = maxHeight;
}

module.exports = { buildReportPDF };