const PDFDocument = require('pdfkit');
const path = require('path');

const LOGO_PATH = path.join(__dirname, '..', 'assets', 'logo.png');

function buildReportPDF(reportData) {
    const doc = new PDFDocument({ bufferPages: true, margin: 50 });

    switch (reportData.reportType) {
        case 'Jobcard':
            buildJobcardReportPDF(doc, reportData);
            break;
        case 'Inventory':
            buildInventoryReportPDF(doc, reportData);
            break;
        case 'Hardware':
            buildHardwareReportPDF(doc, reportData);
            break;
        case 'Consumption':
            buildConsumptionReportPDF(doc, reportData);
            break;
        default:
            generateHeader(doc);
            addMainTitle(doc, 'Unsupported Report');
            doc.font('Helvetica').fontSize(12).text(`PDF generation for report type '${reportData.reportType}' is not currently supported.`, { align: 'center' });
            generateFooter(doc); // Call footer even for the error page
    }
    
    return doc;
}

// --- Builder for Jobcard Reports ---
function buildJobcardReportPDF(doc, reportData) {
    generateHeader(doc);
    addMainTitle(doc, 'Medication Order Report (Jobcard)');
  
    const { Jobcard: jobcard, User: generatedByUser } = reportData;
    if (jobcard) {
        addSectionHeader(doc, 'Jobcard Summary');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Jobcard ID', jobcard.jobcardId, col1), () => addKeyValue(doc, 'Status', jobcard.status, col1), () => addKeyValue(doc, 'Urgency', jobcard.emergencyLevel, col1), () => addKeyValue(doc, 'Quantity', jobcard.quantity, col1), () => addKeyValue(doc, 'Purpose/Notes', jobcard.purpose, col1) ], [ () => addKeyValue(doc, 'Report ID', reportData.reportId, col2), () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => addKeyValue(doc, 'Generated By', generatedByUser?.username, col2) ] ]);
        });
        addSectionHeader(doc, 'Timeline & Personnel');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Requested By', jobcard.requester?.username, col1), () => addKeyValue(doc, 'Request Date', new Date(jobcard.requestDate).toLocaleString(), col1), ], [ () => addKeyValue(doc, 'Approved By', jobcard.approver?.username, col2), () => addKeyValue(doc, 'Approval Date', jobcard.approveDate ? new Date(jobcard.approveDate).toLocaleString() : 'N/A', col2), ] ]);
        });
        if (jobcard.Dilution) {
            addSectionHeader(doc, 'Medication Details');
            drawBoxAround(doc, () => {
                let startY = doc.y; const col1X = 60; const col2X = 340;
                addKeyValue(doc, 'Final Product (Dilution)', jobcard.Dilution?.name, { x: col1X, keyWidth: 150 });
                if (jobcard.Dilution?.Formula) { addKeyValue(doc, 'Recipe Used (Formula)', jobcard.Dilution.Formula.name, { x: col1X, keyWidth: 150 }); }
                const leftHeight = doc.y;
                doc.y = startY;
                if (jobcard.Dilution?.Formula) {
                    doc.font('Helvetica-Bold').fontSize(10).text('Ingredients Required:', col2X, doc.y, { underline: true });
                    doc.moveDown(0.5);
                    const ingredients = jobcard.Dilution.Formula.FormulaDetails;
                    if (ingredients?.length > 0) {
                        ingredients.forEach(detail => { doc.font('Helvetica').fontSize(9).text(`• ${detail.Inventory?.name ?? 'Unknown'} | Qty: ${detail.requiredQuantity}`, col2X + 10, doc.y, { width: 180 }); });
                    } else { doc.font('Helvetica').fontSize(9).text('• No ingredients listed.', col2X + 10); }
                }
                const rightHeight = doc.y;
                doc.y = Math.max(leftHeight, rightHeight);
            });
        }
        addSectionHeader(doc, 'Associated Information');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 110 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Patient Age', jobcard.PrescriptionDetail?.age, col1), () => addKeyValue(doc, 'Patient Weight', `${jobcard.PrescriptionDetail?.weight ?? 'N/A'} kg`, col1), () => addKeyValue(doc, 'Patient Allergies', jobcard.PrescriptionDetail?.allergies, col1) ], [ () => addKeyValue(doc, 'Equipment Used', jobcard.Hardware?.name, col2) ] ]);
        });
    }
    generateFooter(doc);
}

// --- Builder for Inventory Reports ---
function buildInventoryReportPDF(doc, reportData) {
  generateHeader(doc);
  addMainTitle(doc, 'Inventory Item Report');
  
  const { Inventory: item, User: generatedByUser } = reportData;
  if (item) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ],
            [ () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => addKeyValue(doc, 'Generated By', generatedByUser?.username, col2) ]
        ]);
    });
    addSectionHeader(doc, 'Master Product Details');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 120 }; const col2 = { x: 340, keyWidth: 100 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Item ID:', item.inventoryId, col1), () => addKeyValue(doc, 'Item Name:', item.name, col1), () => addKeyValue(doc, 'Unit:', item.unit, col1), ],
            [ () => addKeyValue(doc, 'Total Quantity:', `${item.quantity}`, col2), () => addKeyValue(doc, 'Status:', item.status, col2) ]
        ]);
    });
    addSectionHeader(doc, 'Associated Stock Batches');
    if (item.InventoryStocks?.length > 0) {
      const tableTop = doc.y + 10;
      const idX = 60; const batchX = 110; const supplierX = 250; const qtyX = 400; const expiryX = 460;
      doc.font('Helvetica-Bold').fontSize(10);
      doc.text('ID', idX, tableTop); doc.text('Batch Number', batchX, tableTop); doc.text('Supplier', supplierX, tableTop); doc.text('Qty', qtyX, tableTop, { width: 50, align: 'right' }); doc.text('Expires', expiryX, tableTop);
      doc.moveDown(2);
      doc.font('Helvetica').fontSize(9);
      item.InventoryStocks.forEach(batch => {
        const y = doc.y; if (y > 680) doc.addPage();
        doc.text(batch.inventoryStockId, idX, y);
        doc.text(batch.batchNumber, batchX, y, { width: 130 });
        doc.text(batch.supplier, supplierX, y, { width: 140 });
        doc.text(batch.quantity, qtyX, y, { width: 50, align: 'right' });
        doc.text(batch.expired ? new Date(batch.expired).toLocaleDateString() : 'N/A', expiryX, y);
        doc.moveDown();
      });
    } else {
      doc.font('Helvetica-Oblique').fontSize(10).text('No stock batches found for this item.', { indent: 10 });
    }
  }
  generateFooter(doc);
}

// --- Builder for Hardware Reports ---
function buildHardwareReportPDF(doc, reportData) {
    generateHeader(doc);
    addMainTitle(doc, 'Medical Equipment Report');
    const { Hardware: hardware, User: generatedByUser } = reportData;
    if (hardware) {
        addSectionHeader(doc, 'Report Information');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ], [ () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => addKeyValue(doc, 'Generated By', generatedByUser?.username, col2) ] ]);
        });
        addSectionHeader(doc, 'Equipment Details');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 110 }; const col2 = { x: 340, keyWidth: 120 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Equipment ID:', hardware.hardwareId, col1), () => addKeyValue(doc, 'Equipment Name:', hardware.name, col1), () => addKeyValue(doc, 'Status:', hardware.status ? 'Online / Active' : 'Offline / Inactive', col1) ], [ () => addKeyValue(doc, 'Description:', hardware.description, col2), () => addKeyValue(doc, 'Last Maintenance:', hardware.lastMaintenanceDate ? new Date(hardware.lastMaintenanceDate).toLocaleString() : 'N/A', col2) ] ]);
        });
    }
    generateFooter(doc);
}

// --- Builder for Consumption Reports ---
function buildConsumptionReportPDF(doc, reportData) {
    generateHeader(doc);
    addMainTitle(doc, 'Inventory Consumption Report');
    const { Consumption: consumption, User: generatedByUser } = reportData;
    if (consumption) {
        addSectionHeader(doc, 'Report Information');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ], [ () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => addKeyValue(doc, 'Generated By', generatedByUser?.username, col2) ] ]);
        });
        addSectionHeader(doc, 'Consumption Event');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 110 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Consumption ID:', consumption.consumptionId, col1), () => addKeyValue(doc, 'Date:', new Date(consumption.consumptionDate).toLocaleString(), col1) ], [ () => addKeyValue(doc, 'Item Consumed:', `${consumption.Inventory?.name ?? 'Unknown'} (ID: ${consumption.inventoryId})`, col2), () => addKeyValue(doc, 'Quantity Used:', `${consumption.quantityUsed} ${consumption.Inventory?.unit || ''}`, col2) ] ]);
        });
        addSectionHeader(doc, 'Source of Consumption');
        drawBoxAround(doc, () => {
            const col1 = { x: 60, keyWidth: 140 }; const col2 = { x: 340, keyWidth: 120 };
            drawColumns(doc, [ [ () => addKeyValue(doc, 'Triggering Jobcard ID:', consumption.jobcardId, col1) ], [ () => addKeyValue(doc, 'As part of Formula:', `${consumption.Formula?.name ?? 'Unknown'} (ID: ${consumption.formulaId})`, col2) ] ]);
        });
    }
    generateFooter(doc);
}

// --- Helper Functions for PDF Generation ---

function generateHeader(doc) {
  doc.on('pageAdded', () => {
    const pageWidth = doc.page.width;
    try {
      doc.image(LOGO_PATH, { fit: [60, 60], x: (pageWidth / 2) - 30, y: 20 });
    } catch (e) {
      console.error("PDF Error: Could not load logo.", e.message);
    }
    doc.font('Helvetica-Bold').fontSize(18).text('TheDilution System', 20, 90, { align: 'center' });
    // --- FIX: Added moveDown to create space between the lines ---
    doc.moveDown(0.5);
    doc.font('Helvetica').fontSize(10).text('Hospital Pharmacy Management', { align: 'center' });
    doc.strokeColor("#aaaaaa").lineWidth(1).moveTo(50, doc.y + 10).lineTo(pageWidth - 50, doc.y + 10).stroke();
  });
  doc.emit('pageAdded'); // Trigger for the first page
}

function generateFooter(doc) {
  const range = doc.bufferedPageRange(); // Get the range of pages
  const pageCount = range.count;
  
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i); // Switch to the specific page

    // Get the bottom margin of the current page
    const bottom = doc.page.margins.bottom;
    
    // Draw the horizontal line above the footer
    doc.strokeColor("#aaaaaa").lineWidth(1)
       .moveTo(50, doc.page.height - bottom - 10)
       .lineTo(doc.page.width - 50, doc.page.height - bottom - 10)
       .stroke();

    // Draw the copyright text on the left
    doc.fontSize(8).font('Helvetica-Oblique')
       .text('This is a computer-generated document. © 2025 TheDilution System.', 
       50, doc.page.height - bottom, { align: 'left', lineBreak: false });

    // Draw the page number on the right
    doc.fontSize(10).font('Helvetica')
       .text(`Page ${i + 1} of ${pageCount}`,
       50, doc.page.height - bottom, { align: 'right' });
  }
}

function addMainTitle(doc, title) {
    // Start content below the header line
    doc.y = 150;
    doc.fontSize(16).font('Helvetica-Bold').text(title, { align: 'center' });
    doc.moveDown(2);
}

function addSectionHeader(doc, title) {
  if (doc.y > 650) doc.addPage();
  doc.fontSize(14).font('Helvetica-Bold').text(title, { underline: true });
  doc.moveDown(1);
}

function addKeyValue(doc, key, value, options = {}) {
  const { x, keyWidth = 120 } = options;
  let startY = doc.y;
  const startX = x || doc.x;
  if (startY > 680) { doc.addPage(); startY = doc.y; }
  const valueX = startX + keyWidth;
  const valueWidth = (doc.page.width - doc.page.margins.right) - valueX;
  const keyHeight = doc.heightOfString(key, { width: keyWidth });
  const valueString = `: ${value ?? 'N/A'}`; // Use nullish coalescing for safety
  const valueHeight = doc.heightOfString(valueString, { width: valueWidth });
  doc.font('Helvetica-Bold').fontSize(10).text(key, startX, startY, { width: keyWidth, align: 'left' });
  doc.font('Helvetica').text(valueString, valueX, startY, { width: valueWidth, align: 'left' });
  doc.y = startY + Math.max(keyHeight, valueHeight) + 5;
}

function drawBoxAround(doc, contentCallback) {
    const startY = doc.y;
    const startX = 50;
    if (startY > 650) doc.addPage();
    doc.y += 10;
    contentCallback();
    const finalY = doc.y;
    doc.rect(startX, startY - 5, doc.page.width - 100, finalY - startY).strokeColor("#cccccc").lineWidth(0.5).stroke();
    doc.x = startX;
    doc.y = finalY + 15;
}

function drawColumns(doc, columns) {
    let startY = doc.y;
    let maxHeight = 0;
    columns.forEach(columnItems => {
        doc.y = startY;
        columnItems.forEach(itemFunc => { if (itemFunc) itemFunc(); });
        maxHeight = Math.max(maxHeight, doc.y);
    });
    doc.y = maxHeight;
}

// --- Main export ---
module.exports = { buildReportPDF };