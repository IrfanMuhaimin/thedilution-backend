const PDFDocument = require('pdfkit');

// --- Main Dispatcher Function ---
// This function reads the report type and calls the correct builder.
function buildReportPDF(dataCallback, endCallback, reportData) {
  switch (reportData.reportType) {
    case 'Jobcard':
      return buildJobcardReportPDF(dataCallback, endCallback, reportData);
    case 'Inventory':
      return buildInventoryReportPDF(dataCallback, endCallback, reportData);
    case 'Hardware':
      return buildHardwareReportPDF(dataCallback, endCallback, reportData);
    case 'Consumption':
      return buildConsumptionReportPDF(dataCallback, endCallback, reportData);
    default:
      // Gracefully handle unsupported report types
      const doc = new PDFDocument({ bufferPages: true, margin: 50 });
      doc.on('data', dataCallback);
      doc.on('end', endCallback);
      generateHeader(doc);
      addMainTitle(doc, 'Unsupported Report');
      doc.font('Helvetica').fontSize(12).text(`PDF generation for report type '${reportData.reportType}' is not currently supported.`, { align: 'center' });
      generateFooter(doc);
      doc.end();
  }
}

// --- Builder for Jobcard Reports ---
function buildJobcardReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);

  generateHeader(doc);
  addMainTitle(doc, 'Medication Order Report (Jobcard)');
  
  const { Jobcard: jobcard, User: generatedByUser } = reportData;
  if (jobcard) {
    addSectionHeader(doc, 'Jobcard Summary');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Jobcard ID', jobcard.jobcardId, col1), () => addKeyValue(doc, 'Status', jobcard.status, col1), () => addKeyValue(doc, 'Urgency', jobcard.emergencyLevel, col1), () => addKeyValue(doc, 'Quantity', jobcard.quantity, col1), () => addKeyValue(doc, 'Purpose/Notes', jobcard.purpose, col1) ], [ () => addKeyValue(doc, 'Report ID', reportData.reportId, col2), () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2) ] ]);
    });
    addSectionHeader(doc, 'Timeline & Personnel');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Requested By', jobcard.requester?.username, col1), () => addKeyValue(doc, 'Request Date', new Date(jobcard.requestDate).toLocaleString(), col1), ], [ () => addKeyValue(doc, 'Approved By', jobcard.approver?.username, col2), () => addKeyValue(doc, 'Approval Date', jobcard.approveDate ? new Date(jobcard.approveDate).toLocaleString() : 'N/A', col2), ] ]);
    });
    if (jobcard.Dilution) {
        addSectionHeader(doc, 'Medication Details');
        drawBoxAround(doc, () => {
            let startY = doc.y; const col1X = 60; const col2X = 340;
            addKeyValue(doc, 'Final Product (Dilution)', jobcard.Dilution.name, { x: col1X, keyWidth: 150 });
            if (jobcard.Dilution.Formula) { addKeyValue(doc, 'Recipe Used (Formula)', jobcard.Dilution.Formula.name, { x: col1X, keyWidth: 150 }); }
            const leftHeight = doc.y;
            doc.y = startY;
            if (jobcard.Dilution.Formula) {
                doc.font('Helvetica-Bold').fontSize(10).text('Ingredients Required:', col2X, doc.y, { underline: true });
                doc.moveDown(0.5);
                const ingredients = jobcard.Dilution.Formula.FormulaDetails;
                if (ingredients?.length > 0) {
                    ingredients.forEach(detail => { doc.font('Helvetica').fontSize(9).text(`• ${detail.Inventory.name} | Qty: ${detail.requiredQuantity}`, col2X + 10, doc.y, { width: 180 }); });
                } else { doc.font('Helvetica').fontSize(9).text('• No ingredients listed.', col2X + 10); }
            }
            const rightHeight = doc.y;
            doc.y = Math.max(leftHeight, rightHeight);
        });
    }
    addSectionHeader(doc, 'Associated Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 110 };
        drawColumns(doc, [ [ () => jobcard.PrescriptionDetail && addKeyValue(doc, 'Patient Age', jobcard.PrescriptionDetail.age, col1), () => jobcard.PrescriptionDetail && addKeyValue(doc, 'Patient Weight', `${jobcard.PrescriptionDetail.weight} kg`, col1), () => jobcard.PrescriptionDetail && addKeyValue(doc, 'Patient Allergies', jobcard.PrescriptionDetail.allergies, col1) ], [ () => jobcard.Hardware && addKeyValue(doc, 'Equipment Used', jobcard.Hardware.name, col2) ] ]);
    });
  }
  generateFooter(doc);
  doc.end();
}

// --- Builder for Inventory Reports (Corrected for New Structure) ---
function buildInventoryReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);
  
  generateHeader(doc);
  addMainTitle(doc, 'Inventory Item Report');
  
  const { Inventory: item, User: generatedByUser } = reportData;
  if (item) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ],
            [ () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2) ]
        ]);
    });

    addSectionHeader(doc, 'Master Product Details');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 120 }; const col2 = { x: 340, keyWidth: 100 };
        drawColumns(doc, [
            [ () => addKeyValue(doc, 'Item ID:', item.inventoryId, col1), () => addKeyValue(doc, 'Item Name:', item.name, col1), () => addKeyValue(doc, 'Unit:', item.unit || 'N/A', col1), ],
            [ () => addKeyValue(doc, 'Total Quantity:', `${item.quantity}`, col2), () => addKeyValue(doc, 'Status:', item.status, col2) ]
        ]);
    });

    addSectionHeader(doc, 'Associated Stock Batches');
    if (item.InventoryStocks && item.InventoryStocks.length > 0) {
      const tableTop = doc.y + 10;
      const idX = 60; const batchX = 110; const supplierX = 250; const qtyX = 400; const expiryX = 460;
      doc.font('Helvetica-Bold').fontSize(10);
      doc.text('ID', idX, tableTop); doc.text('Batch Number', batchX, tableTop); doc.text('Supplier', supplierX, tableTop); doc.text('Qty', qtyX, tableTop, { width: 50, align: 'right' }); doc.text('Expires', expiryX, tableTop);
      doc.moveDown(2);

      doc.font('Helvetica').fontSize(9);
      item.InventoryStocks.forEach(batch => {
        const y = doc.y; if (y > 680) doc.addPage();
        doc.text(batch.inventoryStockId, idX, y);
        doc.text(batch.batchNumber || 'N/A', batchX, y, { width: 130 });
        doc.text(batch.supplier || 'N/A', supplierX, y, { width: 140 });
        doc.text(batch.quantity, qtyX, y, { width: 50, align: 'right' });
        doc.text(batch.expired ? new Date(batch.expired).toLocaleDateString() : 'N/A', expiryX, y);
        doc.moveDown();
      });
    } else {
      doc.font('Helvetica-Oblique').fontSize(10).text('No stock batches found for this item.', { indent: 10 });
    }
  }
  generateFooter(doc);
  doc.end();
}

// --- Builder for Hardware Reports ---
function buildHardwareReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);

  generateHeader(doc);
  addMainTitle(doc, 'Medical Equipment Report');

  const { Hardware: hardware, User: generatedByUser } = reportData;
  if (hardware) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ], [ () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2) ] ]);
    });
    addSectionHeader(doc, 'Equipment Details');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 110 }; const col2 = { x: 340, keyWidth: 120 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Equipment ID:', hardware.hardwareId, col1), () => addKeyValue(doc, 'Equipment Name:', hardware.name, col1), () => addKeyValue(doc, 'Status:', hardware.status ? 'Online / Active' : 'Offline / Inactive', col1) ], [ () => addKeyValue(doc, 'Description:', hardware.description, col2), () => addKeyValue(doc, 'Last Maintenance:', hardware.lastMaintenanceDate ? new Date(hardware.lastMaintenanceDate).toLocaleString() : 'N/A', col2) ] ]);
    });
  }
  generateFooter(doc);
  doc.end();
}

// --- Builder for Consumption Reports ---
function buildConsumptionReportPDF(dataCallback, endCallback, reportData) {
  const doc = new PDFDocument({ bufferPages: true, margin: 50 });
  doc.on('data', dataCallback);
  doc.on('end', endCallback);
  
  generateHeader(doc);
  addMainTitle(doc, 'Inventory Consumption Report');
  
  const { Consumption: consumption, User: generatedByUser } = reportData;
  if (consumption) {
    addSectionHeader(doc, 'Report Information');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 90 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Report ID:', reportData.reportId, col1) ], [ () => addKeyValue(doc, 'Generated On', new Date(reportData.generatedDate).toLocaleString(), col2), () => generatedByUser && addKeyValue(doc, 'Generated By', generatedByUser.username, col2) ] ]);
    });
    addSectionHeader(doc, 'Consumption Event');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 100 }; const col2 = { x: 340, keyWidth: 110 };
        drawColumns(doc, [ [ () => addKeyValue(doc, 'Consumption ID:', consumption.consumptionId, col1), () => addKeyValue(doc, 'Date:', new Date(consumption.consumptionDate).toLocaleString(), col1) ], [ () => consumption.Inventory && addKeyValue(doc, 'Item Consumed:', `${consumption.Inventory.name} (ID: ${consumption.Inventory.inventoryId})`, col2), () => consumption.Inventory && addKeyValue(doc, 'Quantity Used:', `${consumption.quantityUsed} ${consumption.Inventory.unit || ''}`, col2) ] ]);
    });
    addSectionHeader(doc, 'Source of Consumption');
    drawBoxAround(doc, () => {
        const col1 = { x: 60, keyWidth: 140 }; const col2 = { x: 340, keyWidth: 120 };
        drawColumns(doc, [ [ () => consumption.Jobcard && addKeyValue(doc, 'Triggering Jobcard ID:', consumption.Jobcard.jobcardId, col1) ], [ () => consumption.Formula && addKeyValue(doc, 'As part of Formula:', `${consumption.Formula.name} (ID: ${consumption.Formula.formulaId})`, col2) ] ]);
    });
  }
  generateFooter(doc);
  doc.end();
}

// --- Helper Functions for PDF Generation ---

function generateHeader(doc) {
  doc.on('pageAdded', () => {
    const pageWidth = doc.page.width;
    doc.image('assets/logo.png', {
      fit: [80, 80],
      align: 'center',
      valign: 'center'
    }).moveDown(0.5);
    doc.font('Helvetica-Bold').fontSize(20).text('TheDilution System', { align: 'center' });
    doc.moveDown(0.3);
    doc.font('Helvetica').fontSize(10).text('Hospital Pharmacy Management', { align: 'center' });
    doc.strokeColor("#aaaaaa").lineWidth(1).moveTo(50, 120).lineTo(pageWidth - 50, 120).stroke();
  });
  doc.emit('pageAdded');
}

function generateFooter(doc) {
  const pageCount = doc.bufferedPageRange().count;
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i);
    const bottom = doc.page.margins.bottom;
    doc.strokeColor("#aaaaaa").lineWidth(1).moveTo(50, doc.page.height - bottom - 10).lineTo(doc.page.width - 50, doc.page.height - bottom - 10).stroke();
    doc.fontSize(8).font('Helvetica-Oblique').text('This is a computer-generated document. © 2025 TheDilution System.', 50, doc.page.height - bottom, { align: 'left' });
    doc.fontSize(10).font('Helvetica').text(`Page ${i + 1} of ${pageCount}`, 0, doc.page.height - bottom, { align: 'right' });
  }
}

function addMainTitle(doc, title) {
    doc.y = 140;
    doc.fontSize(16).font('Helvetica-Bold').text(title, { align: 'center' });
    doc.moveDown(2);
}

function addSectionHeader(doc, title) {
  if (doc.y > 650) doc.addPage();
  doc.fontSize(14).font('Helvetica-Bold').text(title, { underline: true });
  doc.moveDown(1);
}

function addKeyValue(doc, key, value, options = {}) {
  const { x, keyWidth = 120 } = options;
  let startY = doc.y;
  const startX = x || doc.x;
  if (startY > 680) { doc.addPage(); startY = doc.y; }
  const valueX = startX + keyWidth;
  const valueWidth = (doc.page.width - doc.page.margins.right) - valueX;
  const keyHeight = doc.heightOfString(key, { width: keyWidth });
  const valueHeight = doc.heightOfString(`: ${value || 'N/A'}`, { width: valueWidth });
  doc.font('Helvetica-Bold').fontSize(10).text(key, startX, startY, { width: keyWidth, align: 'left' });
  doc.font('Helvetica').text(`: ${value || 'N/A'}`, valueX, startY, { width: valueWidth, align: 'left' });
  doc.y = startY + Math.max(keyHeight, valueHeight) + 5;
}

function drawBoxAround(doc, contentCallback) {
    const startY = doc.y;
    const startX = 50;
    if (startY > 650) doc.addPage();
    doc.y += 10;
    contentCallback();
    const finalY = doc.y;
    doc.rect(startX, startY - 5, doc.page.width - 100, finalY - startY).strokeColor("#cccccc").lineWidth(0.5).stroke();
    doc.x = startX;
    doc.y = finalY + 15;
}

function drawColumns(doc, columns) {
    let startY = doc.y;
    let maxHeight = 0;
    columns.forEach(columnItems => {
        doc.y = startY;
        columnItems.forEach(itemFunc => { if (itemFunc) itemFunc(); });
        maxHeight = Math.max(maxHeight, doc.y);
    });
    doc.y = maxHeight;
}

module.exports = { buildReportPDF };